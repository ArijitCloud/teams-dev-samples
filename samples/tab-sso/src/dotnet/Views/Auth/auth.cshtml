@using Microsoft.Extensions.Configuration
@inject IConfiguration Configuration
@{
    Layout = null;
}

<!DOCTYPE html>
<html>
<head>
    <title>Auth Start Page</title>
</head>
<body>
    
    <p>
        Authorizing...
    </p>

    <script src="https://statics.teams.cdn.office.net/sdk/v1.8.0/js/MicrosoftTeams.min.js" integrity="sha384-5ilKjPffKMvf1YelNqWjOhy5WJC9rkHpgF9pASMY/eRFlb619wOrCGMVIg/a/71o" crossorigin="anonymous"></script>
    <script type="text/javascript" src="https://alcdn.msauth.net/browser/2.7.0/js/msal-browser.min.js" integrity="sha384-isB7RsMD9bXfK4BK9pJHfTyTfQMM/KQ/1a58J/PVsDFbto29TgNxOP3ZyrhRyiTV" crossorigin="anonymous"></script>

    <script>
        (function () {
            'use strict';

            microsoftTeams.initialize(window);

            const msalConfig = {
                auth: {
                    clientId: "@Configuration["ClientId"]",
                    authority: "@Configuration["Authority"]",
                    redirectUri: window.location.origin + "@Configuration["RedirectUriRelativePath"]"
                },
                cache: {
                    cacheLocation: "sessionStorage", // This configures where your cache will be stored
                    storeAuthStateInCookie: false, // Set this to "true" if you are having issues on IE11 or Edge
                }
            };

            let request = {
                scopes: ["User.Read"]
            }

            const msalClient = new msal.PublicClientApplication(msalConfig);

            // Get the tab context, and use the information to navigate to Azure AD login page
            microsoftTeams.getContext((context) => {
                if (!isLoggedIn()) {
                    login(["User.Read", "Mail.Read"]);
                    // This call won't return - catch it on the redirect
                } else {
                    AuthService.getAccessTokenEx(["User.Read", "Mail.Read"])
                        .then(({ username, accessToken, expiresOn }) => {
                            if (accessToken) {
                                const response = JSON.stringify({ username, accessToken, expiresOn })
                                microsoftTeams.authentication.notifySuccess(response);
                            } else {
                                microsoftTeams.authentication.notifyFailure("Unexpected failure - null token received");
                            }
                        })
                        .catch((error) => {
                            console.log(error);
                            microsoftTeams.microsoftTeams.notifyFailure(error);
                        });
                }
            });

            function isLoggedIn() {
                const accounts = msalClient.getAllAccounts();
                return (accounts && accounts.length === 1);
            }

            function login(scopes) {
                if (scopes) {
                    request.scopes = scopes;
                }
                try {
                    msalClient.loginRedirect(this.request);
                }
                catch (err) { console.log(err); }
            }

            // Call this to get the username, access token, and expiration date
            async function getAccessTokenEx(scopes) {

                request.account =
                    msalClient.getAccountByUsername(getUsername());
                if (scopes) {
                    request.scopes = scopes;
                }
                try {
                    let resp = await msalClient.acquireTokenSilent(request);
                    if (resp && resp.accessToken) {
                        return {
                            username: getUsername(),
                            accessToken: resp.accessToken,
                            expiresOn: (new Date(resp.expiresOn)).getTime()
                        }
                    } else {
                        return null;
                    }
                }
                catch (error) {
                    if (error instanceof msal.InteractionRequiredAuthError) {
                        console.warn("Silent token acquisition failed; acquiring token using redirect");
                        msalClient.acquireTokenRedirect(this.request);
                    } else {
                        throw (error);
                    }
                }
            }

            function getUsername() {
                const accounts = msalClient.getAllAccounts();
                let result = null;

                if (accounts && accounts.length === 1) {
                    result = accounts[0].username;
                } else if (accounts && accounts.length > 1) {
                    console.log('ERROR: Multiple users logged in');
                }
                return result;
            }

        })();



            // Generate random state string and store it, so we can verify it in the callback
            let state = _guid();
            localStorage.setItem("auth.state", state);
            localStorage.removeItem("auth.error");
            // See https://docs.microsoft.com/en-us/azure/active-directory/develop/active-directory-v2-protocols-implicit
            // for documentation on these query parameters
            let queryParams = {
                client_id: "@Configuration["ClientId"]",
                response_type: "id_token token",
                response_mode: "fragment",
                scope: "https://graph.microsoft.com/User.Read email openid profile offline_access",
                redirect_uri: window.location.origin + "/auth/auth-end",
                nonce: _guid(),
                state: state,
                login_hint: context.loginHint,
            };
            // Go to the AzureAD authorization endpoint (tenant-specific endpoint, not "common")
            // For guest users, we want an access token for the tenant we are currently in, not the home tenant of the guest.
            let authorizeEndpoint = `https://login.microsoftonline.com/${context.tid}/oauth2/v2.0/authorize?${toQueryString(queryParams)}`;
            window.location.assign(authorizeEndpoint);
        });
        // Build query string from map of query parameter
        function toQueryString(queryParams) {
            let encodedQueryParams = [];
            for (let key in queryParams) {
                encodedQueryParams.push(key + "=" + encodeURIComponent(queryParams[key]));
            }
            return encodedQueryParams.join("&");
        }
        // Converts decimal to hex equivalent
        // (From ADAL.js: https://github.com/AzureAD/azure-activedirectory-library-for-js/blob/dev/lib/adal.js)
        function _decimalToHex(number) {
            var hex = number.toString(16);
            while (hex.length < 2) {
                hex = '0' + hex;
            }
            return hex;
        }
        // Generates RFC4122 version 4 guid (128 bits)
        // (From ADAL.js: https://github.com/AzureAD/azure-activedirectory-library-for-js/blob/dev/lib/adal.js)
        function _guid() {
            // RFC4122: The version 4 UUID is meant for generating UUIDs from truly-random or
            // pseudo-random numbers.
            // The algorithm is as follows:
            //     Set the two most significant bits (bits 6 and 7) of the
            //        clock_seq_hi_and_reserved to zero and one, respectively.
            //     Set the four most significant bits (bits 12 through 15) of the
            //        time_hi_and_version field to the 4-bit version number from
            //        Section 4.1.3. Version4
            //     Set all the other bits to randomly (or pseudo-randomly) chosen
            //     values.
            // UUID                   = time-low "-" time-mid "-"time-high-and-version "-"clock-seq-reserved and low(2hexOctet)"-" node
            // time-low               = 4hexOctet
            // time-mid               = 2hexOctet
            // time-high-and-version  = 2hexOctet
            // clock-seq-and-reserved = hexOctet:
            // clock-seq-low          = hexOctet
            // node                   = 6hexOctet
            // Format: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx
            // y could be 1000, 1001, 1010, 1011 since most significant two bits needs to be 10
            // y values are 8, 9, A, B
            var cryptoObj = window.crypto || window.msCrypto; // for IE 11
            if (cryptoObj && cryptoObj.getRandomValues) {
                var buffer = new Uint8Array(16);
                cryptoObj.getRandomValues(buffer);
                //buffer[6] and buffer[7] represents the time_hi_and_version field. We will set the four most significant bits (4 through 7) of buffer[6] to represent decimal number 4 (UUID version number).
                buffer[6] |= 0x40; //buffer[6] | 01000000 will set the 6 bit to 1.
                buffer[6] &= 0x4f; //buffer[6] & 01001111 will set the 4, 5, and 7 bit to 0 such that bits 4-7 == 0100 = "4".
                //buffer[8] represents the clock_seq_hi_and_reserved field. We will set the two most significant bits (6 and 7) of the clock_seq_hi_and_reserved to zero and one, respectively.
                buffer[8] |= 0x80; //buffer[8] | 10000000 will set the 7 bit to 1.
                buffer[8] &= 0xbf; //buffer[8] & 10111111 will set the 6 bit to 0.
                return _decimalToHex(buffer[0]) + _decimalToHex(buffer[1]) + _decimalToHex(buffer[2]) + _decimalToHex(buffer[3]) + '-' + _decimalToHex(buffer[4]) + _decimalToHex(buffer[5]) + '-' + _decimalToHex(buffer[6]) + _decimalToHex(buffer[7]) + '-' +
                    _decimalToHex(buffer[8]) + _decimalToHex(buffer[9]) + '-' + _decimalToHex(buffer[10]) + _decimalToHex(buffer[11]) + _decimalToHex(buffer[12]) + _decimalToHex(buffer[13]) + _decimalToHex(buffer[14]) + _decimalToHex(buffer[15]);
            }
            else {
                var guidHolder = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx';
                var hex = '0123456789abcdef';
                var r = 0;
                var guidResponse = "";
                for (var i = 0; i < 36; i++) {
                    if (guidHolder[i] !== '-' && guidHolder[i] !== '4') {
                        // each x and y needs to be random
                        r = Math.random() * 16 | 0;
                    }
                    if (guidHolder[i] === 'x') {
                        guidResponse += hex[r];
                    } else if (guidHolder[i] === 'y') {
                        // clock-seq-and-reserved first hex is filtered and remaining hex values are random
                        r &= 0x3; // bit and with 0011 to set pos 2 to zero ?0??
                        r |= 0x8; // set pos 3 to 1 as 1???
                        guidResponse += hex[r];
                    } else {
                        guidResponse += guidHolder[i];
                    }
                }
                return guidResponse;
            }
        };
    </script>
</body>
</html>